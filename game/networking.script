local HOST = 'localhost'
local PORT = 1666
local TIMER_DELAY = 0.05 -- Dunno but kind of seems stable?

function init(self)
	self.is_server = false
	self.server = nil
	self.client = nil
	self.clients = {}

	-- Set up hook hashes so we can get them later
	self.hooks = {}
	for num = 1, 3 do
		-- This will build something like /hook/hook, /hook1/hook, /hook2/hook etc.
		if num == 1 then
			self.hooks[num] = '/hook/hook'
		else
			self.hooks[num] = '/hook' .. num - 1 .. '/hook'
		end
	end

	self.chef = '/chef/chef'

	-- All inputs will be driven from networking
	msg.post('.', 'acquire_input_focus')
end

-- Used for some timer bullshlang
local function no_op()
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed

	-- TODO: Handle disconnects
end

function update(self, dt)
	if self.is_server then
		-- receivefrom tells us host/port info
		local data, host, port = self.server:receivefrom()
		if data then
			local decoded = json.decode(data)
			local command = decoded.command

			print('Server received: ', command)
			
			if command == 'connect' then
				-- creates a player collection
				local collection = collectionfactory.create('#player_factory', nil, nil, {
					[hash('/player')] = { is_server = true, is_self = false }
				})
				-- gets the specific player game object id from the collection
				local player_id = collection[hash("/player")]
				
				-- ??? wtf Lua
				local next_index = #self.clients + 1
				self.clients[next_index] = { host = host, port = port, id = next_index, player_id = player_id }

				-- Tell client about their ID
				self.server:sendto(json.encode({ command = 'client_id', client_id = next_index }), host, port)
			elseif command == 'input' then
				if self.clients[decoded.client_id] then
					local player_id = self.clients[decoded.client_id].player_id
					msg.post(player_id, 'input', { action_id = decoded.action_id, action = decoded.action })
				end
			end
		end

		local players = {}
		for index, client in ipairs(self.clients) do
			local position = go.get_position(client.player_id)
			local rotation = go.get_rotation(client.player_id)
			players[index] = { position_x = position.x, position_y = position.y, rotation_z =  rotation.z, rotation_w = rotation.w }
		end

		local hooks = {}
		for index, hook in ipairs(self.hooks) do
			local position = go.get_position(hook)
			local rotation = go.get_rotation(hook)
			hooks[index] = { position_x = position.x, position_y = position.y, rotation_z =  rotation.z, rotation_w = rotation.w }
		end

		local chef_position  = go.get_position(self.chef)
		local chef = { position_x = chef_position.x, position_y = chef_position.y }

		for _, client in ipairs(self.clients) do
			local message = { command = 'state', players = players, hooks = hooks, chef = chef }
			self.server:sendto(json.encode(message), client.host, client.port)
		end
	end

	if self.client then
		local data = self.client:receive()
		if data then
			local decoded = json.decode(data)
			local command = decoded.command

			print('Client received: ', command)
			
			if command == 'client_id' then
				self.client_id = decoded.client_id
			elseif command == 'chef_angy' then
				msg.post('/chef/chef#chef', 'chef_angy')
			elseif command == 'chef_chop' then
				msg.post('/chef/chef#chef', 'chef_chop')
			elseif command == 'state' then
				for index, player in ipairs(decoded.players) do
					-- If we don't have the client, then create one
					if not self.clients[index] then
						-- is_self indicates whether our flag/inputs should follow a particular player
						local is_self = index == self.client_id
						local collection = collectionfactory.create('#player_factory', nil, nil, {
							[hash('/player')] = { is_server = false, is_self = is_self }
						})

						local player_id = collection[hash('/player')]
						-- Host and port don't really matter since this is client side
						self.clients[index] = { host = '', port = '', id = index, player_id = msg.url(player_id) }
					end

					local player_id = self.clients[index].player_id

					local position_x = player.position_x
					local position_y = player.position_y
					go.set_position(vmath.vector3(position_x, position_y, 0), player_id)

					local rotation_z = player.rotation_z
					local rotation_w = player.rotation_w
					go.set_rotation(vmath.quat(0, 0, rotation_z, rotation_w), player_id)
				end
				
				for index, hook in ipairs(decoded.hooks) do
					local position_x = hook.position_x
					local position_y = hook.position_y
					go.set_position(vmath.vector3(position_x, position_y, 0), self.hooks[index])

					local rotation_z = hook.rotation_z
					local rotation_w = hook.rotation_w
					go.set_rotation(vmath.quat(0, 0, rotation_z, rotation_w), self.hooks[index])
				end

				local chef = decoded.chef
				go.set_position(vmath.vector3(chef.position_x, chef.position_y, 0), self.chef)
			end
		end
	end
end

-- Use these messages to communicate with server/client
-- Other game objects can send messages here to communicate
function on_message(self, message_id, message, sender)
	local data = json.encode(message)

	-- print('Message: ' .. message_id)
	
	if message_id == hash('send_to_all_clients') and self.is_server then
		for _, client in ipairs(self.clients) do
			self.server:sendto(data, client.host, client.port)
		end
	elseif message_id == hash('send_to_all_clients_except') and self.is_server then
		for _, client in ipairs(self.clients) do
			-- Broadcast to everyone except this ID
			if client.id ~= message.except_id then
				self.server:sendto(data, client.host, client.port)
			end
		end
	elseif message_id == hash('send_to_client') and self.is_server then
		local client = self.clients[message.client_id]
		self.server:sendto(data, client.host, client.port)
	elseif message_id == hash('send_to_server') and not self.is_server then
		message.client_id = self.client_id
		data = json.encode(message)
		self.client:send(data)
	end
end

function on_input(self, action_id, action)
	if self.client then
		self.client:send(json.encode({
			client_id = self.client_id,
			command = 'input',
			action_id = action_id,
			action = action
		}))
	end
	
	-- Test commands to send stuff from client or server
	if action_id == hash('network_debug_1') then
		if self.server == nil then
			self.is_server = true
			self.server = socket.udp()
			self.server:settimeout(0)
			self.server:setsockname('*', PORT)
			self.clients = {}

			for _, hook in ipairs(self.hooks) do
				go.set(hook .. '#hook', 'is_server', true)
			end
			
			go.set(self.chef .. '#chef', 'is_server', true)
			
			print('Server started')
		end
	elseif action_id == hash('network_debug_2') then
		if self.client == nil then
			self.client = socket.udp()
			self.client:settimeout(0)
			self.client:setpeername(HOST, PORT)
			self.client_id = -1
			msg.post('.', 'send_to_server', { command = 'connect' })
			print('Client started')
		end
	-- Send something from client to server
	elseif action_id == hash('network_debug_3') then
		msg.post('.', 'send_to_server', { message = 'test message from a client!' })
	-- Send something from server to all clients
	elseif action_id == hash('network_debug_4') then
		msg.post('.', 'send_to_all_clients', { message = 'test message from server!' })
	end
end